<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>è¥¿ç“œéŠæˆ² - å®Œæ•´ç‰ˆ</title>
    <style>
        :root {
            --bg-color: #FFFAE0;
            --panel-bg: #FFF;
            --border-color: #8B4513;
            --danger-color: rgba(255, 0, 0, 0.6);
        }

        body {
            margin: 0;
            background: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            user-select: none;
        }

        /* ä¸»å®¹å™¨ï¼šå‚ç›´æ’åˆ— (ä¸Šæ–¹éŠæˆ²å€ï¼Œä¸‹æ–¹åœ–é‘‘å€) */
        #main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 20px;
        }

        /* éŠæˆ²å€æ°´å¹³å®¹å™¨ (å·¦å´é¢æ¿ + å³å´ç•«å¸ƒ) */
        #game-horizontal-wrapper {
            position: relative;
            display: flex;
            gap: 20px;
        }

        /* å·¦å´è³‡è¨Šæ¬„ */
        #ui-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-box {
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            text-align: center;
            width: 100px;
        }

        .panel-title { font-size: 14px; color: #888; margin-bottom: 5px; font-weight: bold; }
        .panel-value { font-size: 24px; font-weight: bold; color: #333; }
        #next-fruit-display { font-size: 40px; height: 50px; display: flex; align-items: center; justify-content: center; }

        /* éŠæˆ²ç•«å¸ƒå®¹å™¨ */
        #canvas-container {
            position: relative; /* ç‚ºäº†æ”¾ç½® Overlay */
            border-radius: 0 0 20px 20px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
            border: 4px solid var(--border-color);
            border-top: none;
            background: #FFF8E7;
            cursor: crosshair;
        }

        /* Game Over è¦†è“‹å±¤ */
        #game-over-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: none; /* é è¨­éš±è— */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }
        #game-over-overlay h2 { margin: 0 0 10px 0; font-size: 32px; color: #FF4444; }
        #game-over-overlay .final-score { font-size: 24px; margin-bottom: 20px; }
        #restart-btn {
            padding: 10px 25px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #restart-btn:hover { background: #45a049; }

        /* é€²åŒ–åœ–é‘‘å€åŸŸ */
        #evolution-legend {
            background: rgba(255, 255, 255, 0.6);
            padding: 10px 20px;
            border-radius: 30px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 5px;
            max-width: 600px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .legend-item { font-size: 24px; }
        .legend-arrow { color: #999; font-size: 18px; margin: 0 2px; }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

<div id="main-container">
    <div id="game-horizontal-wrapper">
        <div id="ui-panel">
            <div class="panel-box">
                <div class="panel-title">åˆ†æ•¸ SCORE</div>
                <div class="panel-value" id="score">0</div>
            </div>
            <div class="panel-box">
                <div class="panel-title">ä¸‹ä¸€å€‹ NEXT</div>
                <div id="next-fruit-display">ğŸ’</div>
            </div>
            <div class="panel-box" style="background: #FFECEC;">
                <div class="panel-title">æœ€é«˜åˆ† BEST</div>
                <div class="panel-value" id="best-score">0</div>
            </div>
        </div>

        <div id="canvas-container">
            <div id="game-over-overlay">
                <h2>GAME OVER</h2>
                <div class="final-score">Score: <span id="final-score-val">0</span></div>
                <button id="restart-btn">Play Again</button>
            </div>
        </div>
    </div>

    <div id="evolution-legend">
        </div>
</div>

<script>
    // --- è¨­å®šèˆ‡å¸¸æ•¸ ---
    const GAME_WIDTH = 450;
    const GAME_HEIGHT = 700;
    // å±éšªç·šçš„ Y åº§æ¨™ (å¦‚æœä¿®æ”¹é€™è£¡ï¼Œè¨˜å¾—ä¹Ÿè¦ä¿®æ”¹ afterRender è£¡çš„ç¹ªåœ–ä½ç½®)
    const DANGER_LINE_Y = 150; 
    
    const FRUITS = [
        { label: 'cherry', radius: 18, emoji: 'ğŸ’', score: 2 },        // Lv 0
        { label: 'strawberry', radius: 26, emoji: 'ğŸ“', score: 4 },    // Lv 1
        { label: 'grape', radius: 34, emoji: 'ğŸ‡', score: 8 },         // Lv 2
        { label: 'orange', radius: 42, emoji: 'ğŸŠ', score: 16 },       // Lv 3
        { label: 'persimmon', radius: 52, emoji: 'ğŸŸ ', score: 32 },    // Lv 4
        { label: 'apple', radius: 64, emoji: 'ğŸ', score: 64 },        // Lv 5
        { label: 'pear', radius: 76, emoji: 'ğŸ', score: 128 },        // Lv 6
        { label: 'peach', radius: 88, emoji: 'ğŸ‘', score: 256 },       // Lv 7
        { label: 'pineapple', radius: 100, emoji: 'ğŸ', score: 512 },  // Lv 8
        { label: 'melon', radius: 115, emoji: 'ğŸˆ', score: 1024 },     // Lv 9
        { label: 'watermelon', radius: 130, emoji: 'ğŸ‰', score: 2048 } // Lv 10
    ];

    // --- 1. ç”Ÿæˆé€²åŒ–åœ–é‘‘ (HTML) ---
    const legendContainer = document.getElementById('evolution-legend');
    let legendHTML = '';
    FRUITS.forEach((fruit, index) => {
        legendHTML += `<span class="legend-item" title="Level ${index}">${fruit.emoji}</span>`;
        if (index < FRUITS.length - 1) {
            legendHTML += `<span class="legend-arrow">â†’</span>`;
        }
    });
    legendContainer.innerHTML = legendHTML;


    // --- Matter.js åˆå§‹åŒ– ---
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events;

    const engine = Engine.create();
    const world = engine.world;

    const render = Render.create({
        element: document.getElementById('canvas-container'),
        engine: engine,
        options: {
            width: GAME_WIDTH,
            height: GAME_HEIGHT,
            wireframes: false,
            background: 'transparent'
        }
    });

    // --- å»ºæ§‹å ´æ™¯ ---
    const ground = Bodies.rectangle(GAME_WIDTH/2, GAME_HEIGHT + 30, GAME_WIDTH, 100, { isStatic: true });
    const leftWall = Bodies.rectangle(-10, GAME_HEIGHT/2, 20, GAME_HEIGHT * 2, { isStatic: true });
    const rightWall = Bodies.rectangle(GAME_WIDTH + 10, GAME_HEIGHT/2, 20, GAME_HEIGHT * 2, { isStatic: true });
    Composite.add(world, [ground, leftWall, rightWall]);

    // --- éŠæˆ²ç‹€æ…‹è®Šæ•¸ ---
    let gameState = 'playing'; // 'playing' æˆ– 'gameover'
    let currentScore = 0;
    let bestScore = localStorage.getItem('suika-best') || 0;
    document.getElementById('best-score').innerText = bestScore;

    let currentFruitLevel = 0;
    let nextFruitLevel = Math.floor(Math.random() * 2); // é–‹å±€åªçµ¦å‰å…©ç¨®
    let isDropping = false;
    let mouseX = GAME_WIDTH / 2;

    // è¼”åŠ©å‡½æ•¸
    function updateNextFruitDisplay() {
        document.getElementById('next-fruit-display').innerText = FRUITS[nextFruitLevel].emoji;
    }
    updateNextFruitDisplay();

    function updateScore(points) {
        currentScore += points;
        document.getElementById('score').innerText = currentScore;
        if(currentScore > bestScore) {
            bestScore = currentScore;
            localStorage.setItem('suika-best', bestScore);
            document.getElementById('best-score').innerText = bestScore;
        }
    }

    function triggerGameOver() {
        if (gameState === 'gameover') return;
        gameState = 'gameover';
        Runner.stop(runner); // åœæ­¢ç‰©ç†å¼•æ“
        document.getElementById('final-score-val').innerText = currentScore;
        document.getElementById('game-over-overlay').style.display = 'flex';
    }

    // é‡ç½®éŠæˆ²
    document.getElementById('restart-btn').addEventListener('click', () => {
        // æ¸…ç©ºå ´æ™¯ä¸­çš„æ°´æœ
        const allBodies = Composite.allBodies(world);
        allBodies.forEach(body => {
            if (body.label === 'fruit') Composite.remove(world, body);
        });
        
        // é‡ç½®è®Šæ•¸
        currentScore = 0;
        document.getElementById('score').innerText = 0;
        gameState = 'playing';
        isDropping = false;
        currentFruitLevel = 0;
        nextFruitLevel = Math.floor(Math.random() * 3);
        updateNextFruitDisplay();
        document.getElementById('game-over-overlay').style.display = 'none';
        Runner.run(runner, engine); // é‡å•Ÿå¼•æ“
    });

    // --- æ ¸å¿ƒé‚è¼¯ï¼šGame Over æª¢æŸ¥ ---
    // åœ¨æ¯æ¬¡ç‰©ç†æ›´æ–°å¾Œæª¢æŸ¥
    Events.on(engine, 'afterUpdate', function() {
        if (gameState !== 'playing') return;

        const bodies = Composite.allBodies(world);
        for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            if (body.label === 'fruit' && !body.isRemoved) {
                // è¨ˆç®—æ°´æœçš„ã€Œæœ€é«˜é»ã€Yåº§æ¨™
                const topY = body.position.y - body.circleRadius;
                
                // åˆ¤å®šæ¢ä»¶ï¼š
                // 1. æ°´æœé ‚éƒ¨é«˜æ–¼å±éšªç·š (Y å€¼è¶Šå°è¶Šé«˜)
                // 2. æ°´æœå¹¾ä¹éœæ­¢ (speed < 0.2) - é¿å…å‰›æ‰ä¸‹ä¾†ç¶“éç·šæ™‚èª¤åˆ¤
                // 3. ç¢ºä¿ä¸æ˜¯å‰›ç”Ÿæˆåœ¨ç•«é¢å¤–çš„ (topY > 0)
                if (topY < DANGER_LINE_Y && body.speed < 0.2 && topY > 0) {
                    // ç‚ºäº†å¢åŠ å®¹éŒ¯ç‡ï¼ŒçœŸæ­£çš„éŠæˆ²é€šå¸¸æœƒè¨ˆç®—ã€Œåœç•™æ™‚é–“ã€
                    // é€™è£¡ç°¡åŒ–è™•ç†ï¼šåªè¦åµæ¸¬åˆ°éœæ­¢ä¸”è¶…ç·šï¼Œå°±çµæŸ
                    console.log("Game Over triggered by fruit ID:", body.id);
                    triggerGameOver();
                    break; // åªè¦æœ‰ä¸€å€‹è¶…ç·šå°±çµæŸ
                }
            }
        }
    });

    // --- æ¸²æŸ“å¾ªç’° (ç•« Emoji å’Œè¼”åŠ©ç·š) ---
    Events.on(render, 'afterRender', function() {
        const context = render.context;
        
        // 1. ç•«å‡ºå±éšªç·š (è¦åœ¨æ°´æœä¸‹é¢ï¼Œæ‰€ä»¥å…ˆç•«æˆ–æ˜¯ç”¨ globalCompositeOperation)
        context.save();
        context.beginPath();
        context.moveTo(0, DANGER_LINE_Y);
        context.lineTo(GAME_WIDTH, DANGER_LINE_Y);
        context.strokeStyle = "rgba(255, 50, 50, 0.6)";
        context.lineWidth = 3;
        context.setLineDash([10, 5]); // è™›ç·š
        context.stroke();
        context.restore();

        // 2. ç•«å‡ºæ‰€æœ‰æ°´æœ Emoji
        const bodies = Composite.allBodies(world);
        context.font = "30px Arial";
        context.textAlign = "center";
        context.textBaseline = "middle";

        bodies.forEach(body => {
            if (body.label === 'fruit' && !body.isRemoved) {
                const fruit = FRUITS[body.customLevel];
                context.save();
                context.translate(body.position.x, body.position.y);
                context.rotate(body.angle);
                // ç•«åœ“å½¢èƒŒæ™¯
                context.beginPath();
                context.arc(0, 0, fruit.radius, 0, 2 * Math.PI);
                context.fillStyle = "#FFF0D0";
                context.fill();
                // ç•« Emoji
                context.font = `${fruit.radius * 1.55}px sans-serif`;
                context.fillText(fruit.emoji, 0, fruit.radius * 0.1); 
                context.restore();
            }
        });

        // 3. ç•«å‡ºæº–å‚™æ‰è½çš„æ°´æœèˆ‡ç„æº–ç·š
        if (!isDropping && gameState === 'playing') {
            const fruit = FRUITS[currentFruitLevel];
            // ç„æº–ç·š
            context.beginPath();
            context.moveTo(mouseX, 50);
            context.lineTo(mouseX, GAME_HEIGHT);
            context.strokeStyle = "rgba(0,0,0,0.2)";
            context.setLineDash([5, 5]);
            context.stroke();
            context.setLineDash([]);
            // æ‰‹ä¸­çš„æ°´æœ
            context.save();
            context.translate(mouseX, 50);
            context.font = `${fruit.radius * 1.55}px sans-serif`;
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.fillText(fruit.emoji, 0, fruit.radius * 0.1);
            context.restore();
        }
    });

    // --- æ“æ§ ---
    render.canvas.addEventListener('mousemove', (e) => {
        if (gameState !== 'playing') return;
        const rect = render.canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        const radius = FRUITS[currentFruitLevel].radius;
        // é™åˆ¶åœ¨ç‰†å£å…§
        x = Math.max(radius + 5, Math.min(GAME_WIDTH - radius - 5, x));
        mouseX = x;
    });

    render.canvas.addEventListener('mousedown', (e) => {
        if (isDropping || gameState !== 'playing') return;
        isDropping = true;
        const level = currentFruitLevel;
        const radius = FRUITS[level].radius;
        
        // ç¨å¾®æé«˜ç”Ÿæˆé»ï¼Œè®“å®ƒæœ‰è½ä¸‹çš„æ„Ÿè¦º
        const spawnY = 30; 
        const body = Bodies.circle(mouseX, spawnY, radius, {
            label: 'fruit',
            restitution: 0.2, density: 0.001, friction: 0.1,
            customLevel: level
        });
        Composite.add(world, body);

        setTimeout(() => {
            currentFruitLevel = nextFruitLevel;
            // éš¨æ©Ÿç”Ÿæˆ Level 0~3
            nextFruitLevel = Math.floor(Math.random() * 4); 
            updateNextFruitDisplay();
            isDropping = false;
        }, 800); // å†·å»æ™‚é–“
    });

    // --- åˆæˆ ---
    Events.on(engine, 'collisionStart', (event) => {
        if (gameState !== 'playing') return;
        event.pairs.forEach((collision) => {
            const bodyA = collision.bodyA;
            const bodyB = collision.bodyB;
            if (bodyA.label === 'fruit' && bodyB.label === 'fruit') {
                if (bodyA.customLevel === bodyB.customLevel && !bodyA.isRemoved && !bodyB.isRemoved) {
                    bodyA.isRemoved = true; bodyB.isRemoved = true;
                    const newLevel = bodyA.customLevel + 1;
                    updateScore(FRUITS[bodyA.customLevel].score);
                    
                    if (newLevel < FRUITS.length) {
                        const newX = (bodyA.position.x + bodyB.position.x) / 2;
                        const newY = (bodyA.position.y + bodyB.position.y) / 2;
                        const newBody = Bodies.circle(newX, newY, FRUITS[newLevel].radius, {
                            label: 'fruit', restitution: 0.2, customLevel: newLevel
                        });
                        Composite.remove(world, [bodyA, bodyB]);
                        Composite.add(world, newBody);
                    } else {
                        // åˆæˆåˆ°æœ€å¤§(è¥¿ç“œ)ï¼Œç›´æ¥ç§»é™¤ä¸¦åŠ å¾ˆå¤šåˆ†
                         updateScore(FRUITS[newLevel-1].score * 2);
                         Composite.remove(world, [bodyA, bodyB]);
                    }
                }
            }
        });
    });

    // å•Ÿå‹•
    const runner = Runner.create();
    Runner.run(runner, engine);
    Render.run(render);

</script>
</body>
</html>